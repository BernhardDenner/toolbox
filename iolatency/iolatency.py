#!/usr/bin/env python3
import os
import sys
from threading import Timer
import time
import logging

# most of this was generated by ChatGPT3.5, Co-Pilot, and me
# Bdenner: 2024-10-10

# Define constants
CHUNK_SIZE = 102400
CHUNKS_TO_WRITE = 1

# latencies bigger than this will trigger a warning message
WARNING_THRESHOLD = 0.2

PROMETHEUS_TEXTFILE_PATH = '/var/lib/prometheus/node-exporter/iolatency.prom'

logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')


class IOLatencyMonitor:
    def __init__(self, file_path):
        self.file_path = file_path
        self.highest_delta = 0
        self.window_size = 100
        self.recent_deltas = []
        self.rolling_avg = 0
        self.fsync_runs = 0
        self.latency_sum = 0
        self.timers = {}

    def log_rolling_avg(self):
        logging.info(f"rolling average: {self.rolling_avg * 1000:.2f}ms")
        self.timers['rolling_avg'] = Timer(10, self.log_rolling_avg)
        self.timers['rolling_avg'].start()

    def write_prometheus_metrics(self):
        with open(f"{PROMETHEUS_TEXTFILE_PATH}.tmp", 'w') as f:
            f.write(f'# HELP iolatency_latency Highest measured latency in milliseconds\n')
            f.write(f'# TYPE iolatency_latency gauge\n')
            f.write(f'iolatency_latency {self.highest_delta * 1000:.2f}\n')
            f.write(f'# HELP iolatency_rolling_avg Rolling average of latencies in milliseconds\n')
            f.write(f'# TYPE iolatency_rolling_avg gauge\n')
            f.write(f'iolatency_rolling_avg {self.rolling_avg * 1000:.2f}\n')
            f.write(f'# HELP iolatency_fsync_count Number of fsync runs\n')
            f.write(f'# TYPE iolatency_fsync_count gauge\n')
            f.write(f'iolatency_fsync_count {self.fsync_runs}\n')
            f.write(f'# HELP iolatency_latency_sum_ms Sum of all latencies in milliseconds\n')
            f.write(f'# TYPE iolatency_latency_sum_ms gauge\n')
            f.write(f'iolatency_latency_sum_ms {self.latency_sum * 1000:.2f}\n')
        os.rename(f"{PROMETHEUS_TEXTFILE_PATH}.tmp", PROMETHEUS_TEXTFILE_PATH)

        self.timers['prom'] = Timer(10, self.write_prometheus_metrics)
        self.timers['prom'].start()

    def reset_highest_delta(self):
        self.highest_delta = 0
        self.timers['reset_top'] = Timer(5 * 60, self.reset_highest_delta)
        self.timers['reset_top'].start()


    def start(self):
        logging.info(f"writing {CHUNK_SIZE * CHUNKS_TO_WRITE / 1024:.2f}KB random data to file '{self.file_path}'")

        if os.access(os.path.dirname(PROMETHEUS_TEXTFILE_PATH), os.W_OK):
            logging.info(f"writing prometheus metrics to '{PROMETHEUS_TEXTFILE_PATH}'")
            self.write_prometheus_metrics()
        else:
            logging.warning(f"cannot write to '{PROMETHEUS_TEXTFILE_PATH}', prometheus metrics are not available")

        self.reset_highest_delta()
        self.log_rolling_avg()

        with open(self.file_path, 'w') as fd:
            while True:
                try:
                    os.lseek(fd.fileno(), 0, os.SEEK_SET)

                    start_time = time.time()

                    for _ in range(CHUNKS_TO_WRITE):
                        fd.write(os.urandom(CHUNK_SIZE).hex())
                    fd.flush()
                    os.fsync(fd.fileno())

                    end_time = time.time()
                    delta = end_time - start_time
                    self.latency_sum += delta
                    self.fsync_runs += 1

                    self.recent_deltas.append(delta)
                    if len(self.recent_deltas) > self.window_size:
                        self.recent_deltas.pop(0)

                    self.rolling_avg = sum(self.recent_deltas) / len(self.recent_deltas)

                    if delta > self.highest_delta:
                        logging.info("new high: %.2fms, was %.2fms" % (delta * 1000, self.highest_delta * 1000))
                        self.highest_delta = delta

                    if delta > WARNING_THRESHOLD:
                        logging.warning(f"high latency: {delta * 1000:.2f}ms")

                    time.sleep(0.1)
                except KeyboardInterrupt:
                    logging.info("Exiting.")
                    break
                except Exception as e:
                    logging.error("Exception:", e)
                    break

        logging.info(f"highest measured latency: {self.highest_delta * 1000:.2f}ms")
        logging.info(f"deleting file '{self.file_path}'")
        os.unlink(self.file_path)
        for timer in self.timers.values():
            timer.cancel()
        sys.exit(0)


def main():
    if len(sys.argv) != 2:
        print(f"usage: {sys.argv[0]} <path to file to write>")
        sys.exit(1)

    file_path = sys.argv[1]
    monitor = IOLatencyMonitor(file_path)
    monitor.start()

if __name__ == "__main__":
    main()

